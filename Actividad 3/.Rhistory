pi2
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {((1/s)*log10(pi2+(exp((h*s))*pi1))}
h
h<-0.1
Q<-matrix(c(-l,u,l,-u),2,2)
H<-matrix(c(0,0,0,h),2,2)
V<-matrix(1,2,2)
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {((1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
s
t
z
pi1
pi2
Bw
l<-138.185
u<-0.01034
h<-0.01
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {((1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
z
l<-0.4
u<-0.3
h<-0.1
pi1<-l/(l+u)
pi2<-u/(l+u)
pi2
pi1
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {((1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-138.185
u<-0.01034
h<-0.01
l<-0.01012
u<-0.01034
h<-0.01
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
h
u
l
l<-0.02
u<-0.1
h<-0.01
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-0.4
u<-0.3
h<-3
Q<-matrix(c(-l,u,l,-u),2,2)
H<-matrix(c(0,0,0,h),2,2)
V<-matrix(1,2,2)
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
h<-0.1
Q<-matrix(c(-l,u,l,-u),2,2)
H<-matrix(c(0,0,0,h),2,2)
V<-matrix(1,2,2)
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-0.4
u<-0.3
h<-0.5
Q<-matrix(c(-l,u,l,-u),2,2)
H<-matrix(c(0,0,0,h),2,2)
V<-matrix(1,2,2)
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-0.4
u<-0.3
h<-0.1
Q<-matrix(c(-l,u,l,-u),2,2)
H<-matrix(c(0,0,0,h),2,2)
V<-matrix(1,2,2)
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-138.185
u<-0.01034
h<-0.01
#Distribución invariante es un vector de probabilidad pi tal que piQ=0, entonces:
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
pi1
l<-0.02
u<-0.1
h<-0.01
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
l<-0.4
u<-0.3
h<-0.1
pi1<-l/(l+u)
pi2<-u/(l+u)
space<-seq(length=50, from=1, to=100)
time<-seq(length=50, from=1, to=30) #ms
s<-(space)
t<-(time)
Bw<-function(t,s) {(1/s)*log10(pi2+(exp((h*s))*pi1))}
z<-outer(t,s,Bw)     # La función outer evalua la función Bw en cada punto(si,tj)
nrz<-nrow(z)
ncz<-ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors<-colorRampPalette(c("blue","violet"))
# Generate the desired number of colors from this palette
nbcol<-100
color<-jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet<-z[−1,−1]+z[−1,−ncz]+z[−nrz,−1] +z[−nrz,−ncz]
# Recode facet z-values into color indices
facetcol<-cut(zfacet,nbcol)
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=0,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp(t,s,z,theta=30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp(t,s,z,theta=-30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=-30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=-30,phi=0,col = color[facetcol],
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=-30,phi=0,col = color[facetcol],back="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=-30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
persp3d(t,s,z,theta=-30,phi=0,col = color[facetcol],front="lines",
sub="Ancho de banda efectivo de una fuente ON/OFF",
ticktype = "detailed",xlab="time (ms)",ylab="space (s)",zlab="(s,t)")
C<-37
B<-5
u<-35.09
var<-25.53
H<-0.75
s<-(B+(C+u)*t)/(var*t^(2*H)) #0.0355
t<-(B/(C-u))*(H/(1-H))      #8
Bw_MFB<-u+(((s*var)/2)*(t^(2*H-1)))
Bw_MFB
s
C<-37
B<-5
u<-35.09
var<-25.53
H<-0.75
t<-(B/(C-u))*(H/(1-H))      #8
s<-(B+(C+u)*t)/(var*t^(2*H)) #0.0355
Bw_MFB<-u+(((s*var)/2)*(t^(2*H-1)))
Bw_MFB
t
s
Bw<-function(s,t) {log10(l+((((o^2)*(t^((2*H)-1)))/2)*s))}
z<-outer(t,s,Bw) # La función outer evalua la función Bw en cada punto(si,tj)
persp((t),(s),(z),theta=20,phi=-0,col = "lightblue", main="Ancho de Banda Efectivo",
ticktype ="detailed",xlab="t (ms)",ylab="s",zlab="(s,t)")
Bw<-function(t,s) {log10(l+((((o^2)*(t^((2*H)-1)))/2)*s))}
z<-outer(t,s,Bw) # La función outer evalua la función Bw en cada punto(si,tj)
persp((t),(s),(z),theta=20,phi=-0,col = "lightblue", main="Ancho de Banda Efectivo",ticktype ="detailed",xlab="t (ms)",ylab="s",zlab="(s,t)")
t
s
z
l<-138.185 #bytes por segundo
var<-89.668^2 # varianza
H<-0.81
t<-(seq(length=100, from=0.0001, to=10))    #time parameter (ms)
s<-(seq(length=100, from=0.00001, to=0.01)) #space parameter (bytes^-1)
l<-138.185 #bytes por segundo
var<-89.668^2 # varianza
H<-0.81
t<-(seq(length=100, from=0.0001, to=10))    #time parameter (ms)
s<-(seq(length=100, from=0.00001, to=0.01)) #space parameter (bytes^-1)
Bw<-function(t,s) {log10(l+((((o^2)*(t^((2*H)-1)))/2)*s))}
z<-outer(t,s,Bw) # La función outer evalua la función Bw en cada punto(si,tj)
persp((t),(s),(z),theta=20,phi=-0,col ="lightblue", sub="Ancho de Banda Efectivo",ticktype ="detailed",xlab="t (ms)",ylab="s",zlab="(s,t)")
set.seed(100)
x <- rnorm(1024)
walk <- cumsum(x)
## calculate the Hurst coefficient of a random
## walk series using various techniques
methods <- c("aggabs","aggvar","diffvar","higuchi")
z <- lapply(methods, function(method, walk){
hurstBlock(ifelse1(method=="higuchi",diff(walk),walk), method=method)
},walk=walk )
names(z) <- methods
## plot results
old.plt <- splitplot(2,2,1)
for (i in 1:4){
if (i > 1)
splitplot(2,2,i)
plot(z[[i]], key=FALSE)
mtext(paste(attr(z[[i]],"stat.name"), round(as.numeric(z[[i]]),3), sep=", H="),
line=0.5, adj=1)
}
par(old.plt)
library(fractal)
## create test series
set.seed(100)
x <- rnorm(1024)
walk <- cumsum(x)
## calculate the Hurst coefficient of a random
## walk series using various techniques
methods <- c("aggabs","aggvar","diffvar","higuchi")
z <- lapply(methods, function(method, walk){
hurstBlock(ifelse1(method=="higuchi",diff(walk),walk), method=method)
},walk=walk )
names(z) <- methods
## plot results
old.plt <- splitplot(2,2,1)
for (i in 1:4){
if (i > 1)
splitplot(2,2,i)
plot(z[[i]], key=FALSE)
mtext(paste(attr(z[[i]],"stat.name"), round(as.numeric(z[[i]]),3), sep=", H="),
line=0.5, adj=1)
}
par(old.plt)
## create test series
set.seed(100)
x <- rnorm(1024)
walk <- cumsum(x)
## calculate the Hurst coefficient of a random
## walk series using various techniques. use a
## multitaper SDF
methods <- c("standard","smoothed")
z <- lapply(methods, function(method, walk){
hurstSpec(walk, method=method, sdf.method="multitaper")
},walk=walk )
names(z) <- methods
## plot results
old.plt <- par("plt")
for (i in 1:2){
splitplot(2,1,i)
plot(z[[i]])
}
hurstACVF(wmtsa::nile, Ascale=1000000, lag.min=3, lag.max=68)
wmtsa::nile
set_belly
set_bellx
set_belly
set_belly
set_bellx
set_bellx
x
wmtsa::nile
hurstACVF(set_belly, Ascale=1000000, lag.min=3, lag.max=68)
hurstACVF(set_bellx, Ascale=1000000, lag.min=3, lag.max=68)
x <- rnorm(1024)
walk <- cumsum(x)
x
walk
x
library("longmemo", lib.loc="~/R/win-library/3.1")
C<-52 #tasa de servicio
u<-seq(length=30, from=10, to=60) #tasa promedio de arribos #50,83
var<-30.18
s<-(2*(C-u))/var
Bw_MB<-u+((s*var)/2)
plot(u,s)
lot(s,Bw_MB)
plot(s,Bw_MB)
aggvarFit(x, levels = 50, minnpts = 3, cut.off = 10^c(0.7, 2.5),
doplot = TRUE, trace = FALSE, title = NULL, description = NULL)
library("fArma", lib.loc="~/R/win-library/3.1")
library(fArma)
library(longmemo)
x<-data(ethernetTraffic)
x<-data(ethernetTraffic)
library(somebm)
